\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1 in]{geometry}
\usepackage{graphicx}
\usepackage[colorlinks]{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{float} %for floating images
\usepackage[table,xcdraw]{xcolor} %for colored tables

\hypersetup{
  colorlinks=true,
  urlcolor=blue
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}


\author{Matheus Augusto da Silva - Alessandro Montaldo}
\title{\textbf{SR2I 203 - État de l'art, études initiaux}}
\date{\today}

\begin{document}
\maketitle
%--------------------------
\section{Introduction}
Notre projet s'agit de réaliser un étude et une implémentation d'un type spécifique d'attaque DoS; il s'agit d'un attaque Low and Slow, plus spécifiquement,
l'attaque slowloris. L'objectif de ce rapport est d'introduire les études et progrès faites, ainsi comme expliquer et motives nos prochains pas.
Notamment on a suivi le chemin à la suite:

\begin{itemize}
	\item un étude avec la priorité de comprendre la fonctionnalité principal du protocole HTTP et d'un serveur Web
	\item une recherche capable de bien comprendre le fonctionnement du attaque slowloris
	\item réaliser une implémentation d'un petit programme capable d'envoyer requêtes GET
\end{itemize}

%--------------------------
\section{Étude du Protocole HTTP}
Hypertext Transfer Protocol a été conçu avec le but de construire une architecture client-serveur tel que l'on peut implémenter un déploiement du WWW. C'est un protocole de la couche application et il permet l'implémentation d'un des outils les plus populaires d'Internet aujourd'hui: le navigateur Web.
Le principe c'est d'une architecture où un site web (serveur ou ensemble de serveurs) est associé à plusieurs ressources lesquelles un client peut demander via les méthodes HTTP. Un serveur web peut être identifié par son URL ou son adresse IP et généralement garde informations comme pages web, images et fichiers.

\subsection{HTTP Requests and responses}
Chaque rêquete commence avec un \textit{Request-Line} indiquant la méthode HTTP à être utilisée, la ressource que l'on veut demander (ou envoyer) et la version du protocole HTTP que le client peut supporter. Le corps du message peut être séparé de l'entête via une ligne vide, lorsque ce qui signalise la fin d'une message HTTP est une séquence de deux lignes vides.

\noindent
Réponses HTTP sont très similaires à requêtes HTTP. La seule différence significative est que réponses commencent avec un \textit{status line} lorsque
requêtes ont pour début une \textit{request line}.

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.6\textwidth]{images/getRequest.png} % Include the image placeholder.png
		\caption{Exemple de GET request.}
                \label{get-request}
	\end{center}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.6\textwidth]{images/ok.png} % Include the image placeholder.png
		\caption{Exemple de message OK.}
	\end{center}
\end{figure}

%--------------------------
\section{Étude du Serveur Web Apache}
Apache est le serveur Web le plus populaire sur Internet. Plus que la majorité des sites Web sont basés sur lui. Ce qui rend Apache vulnérable à l'attaque qui sera analysé, c'est la manière dont il traite ses clients. En particulier, après avoir reçu une requête HTTP, un nouveau fil associé à cette conversation s'ouvrira. \\
Les serveurs Apache plus anciens utilisent un modèle de limitation de \textit{threads}, généralement un serveur Apache normal peut ouvrir environ 200 threads en parallèle. Normalement, la limitation n’est pas un problème pour les serveurs de site de petite taille, dans la mesure où ils n’ont pas besoin de gérer leur trafic.
Le serveur est fourni avec une variété de Modules Multi-Processus (MPMs) qui sont responsables de l'association aux ports réseau de la machine, acceptent les requêtes, et se chargent de répartir ces dernières entre les différents processus enfants. \\

\noindent
La table suivante fournit la liste des MPMs par défaut pour divers systèmes d'exploitation: \\

\begin{table}[H]
  \centering
\begin{tabular}{|
>{\columncolor[HTML]{EFEFEF}}l |
>{\columncolor[HTML]{EFEFEF}}l |}
\hline
Netware & mpm\_netware                                                                                                  \\ \hline
OS/2    & mpmt\_os2                                                                                                     \\ \hline
Unix    & \begin{tabular}[c]{@{}l@{}}prefork, worker,\\ ou event, selon les possibilités de la plate-forme\end{tabular} \\ \hline
Windows & mpm\_winnt                                                                                                    \\ \hline
\end{tabular}
\end{table}

\noindent
En supposant que le serveur supporte le \textit{multi-threading}, un processus parent sera généré et responsabilisé de créer les processus enfants. Chaque processus enfant va créer un nombre fixe de threads du serveurs selon la valeur du paramètre \textit{ThreadsPerChild} (25 par défaut), ainsi qu'un thread chargé d'attendre les connexions et de les passer à un thread serveur pour traitement au fur et à mesure de leur arrivée. \\
Le nombre maximum de clients pouvant être servis simultanément (c'est à dire le nombre global maximum de threads pour tous les processus) est défini par la directive MaxRequestWorkers (256 par défaut).

\subsection{Nginx vs Apache}
Nginx a été créé pour résoudre le problème de la gestion d’un grand nombre de connexions. En fait, au lieu d’une architecture à base de threads, comme Apache, Nginx a une architecture pilotée par les événements qui ne crée pas de nouveau processus pour chaque requête. Dans notre projet, nous testerons l’attaque de slowloris sur différents serveurs Web et verrons si l’expérimentation réussira.

%--------------------------
\section{Étude du attaque Slowloris}
L'idée de base de l'attaque de slowloris est d'ouvrir de nombreuses connexions en envoyant des requêtes HTTP partielles. Des fractions de la demande sont envoyées ultérieurement à intervalles réguliers pour empêcher les sockets de se fermer. \\
L'attaque se différencie d'autres attaques DoS comme les \textit{SYN flood attacks} qui exploitent la mécanique de synchronisation TCP (le paquet TCP SYN) pendant la négociation du \textit{three-way-handshake} \\
On peut diviser un exploit suivant l'algorithme suivant: \\
\begin{itemize}
	\item On crée une requête GET destinée au serveur cible
	\item On envoie la requête très lentement et d'une façon incomplète
	\item On répète la même procédure avec un numero très grand de messages, entre 100 et 200, dépendant des configurations du serveur.
	\item Chaque GET répondu sera interprète dans le serveur comme un nouveau client; ça ouvre un nouveau thread dans le réservoir limité du serveur.
	\item Avec le temps, les requêtes lentes mais continues de la machine attaquante iront remplacer tous les connexions "légitimes".
\end{itemize}

\subsection{Détectabilité}
Une propriété désirable du attaque est sa capacité de n'être pas détecté. Un attaque DoS lent ne sera pas détecte pour Systèmes de Détection d'Intruses (IDS) dès que l'attaque ne contient pas requêtes malformés. Requêtes HTTP qui semblent légitimes passeront par l'IDS et seront acheminées au serveur Web. Les \textit{logs} du serveur seront mis à jour juste après que les requêtes soient complétés, ce qui veut dire qu'après un attaque de cette nature les fichiers \textit{logs} verront le flux de plusieurs messages du type 400 ( erreurs HTTP ). Une idée à être considérée c'est de mettre en place un \textit{timer} qui accompagne l'évolution des requêtes HTTP, responsable pour fermer les connexions d'une façon valide avant la fermeture du dialogue.

%--------------------------
\section{Implémentation en Python}

\subsection{Programmation}
Le travail d'implémentation a commencé en déterminant les aspects principaux requises. Fonctionnellement, nous avions
besoin d'un petit programme capable d’envoyer requêtes HTTP.Comme nous disons la section d'avant,
l'attaque \textit{slowloris} est fonctionnellement très élégant; en exploitant le mécanisme des GET
requests du protocole HTTP plusieurs fois, on occupe tous les \textit{threads} disponibles au serveur.
Alors, comme le but de notre état de l'art, on a fixé l'objectif d’implémenter un programme capable d'envoyer
GET requests à un serveur web HTTP.Cette fonctionnalité pourra après être déléguée à une fonction en python,
que l'on appellera lors de l'attaque dans une structure de contrôle plus intelligente.
Le but est d'utiliser les méthodes de Scapy, ce qui nous donnera la capacité de contrôler d'une façon plus granulaire
l'envoie des paquets. Le code source est travaillé et managé à travers de
git et le dépôt est disponible publiquement sur Github (documenté en anglais) sur le lien \href{https://github.com/AlessandroMontaldo/slowLorisAttack}{https://github.com/AlessandroMontaldo/slowLorisAttack}

\newpage
\begin{lstlisting}
#!/usr/bin/env python
# Imports
from scapy.all import *
#import scapy_http.http

# TITLE: http.py
# AUTHORS: Matheus Augusto da Silva; Alessandro Montaldo
# OBS: The following command stops Linux machines from dropping
# the packets generated by scapy (run as root):
# iptables -A OUTPUT -p tcp --tcp-flags RST RST -j DROP

# The goal is to send a well-formated GET request, and not to wait
# for a reponse (200 OK) from the server.
# For the next part of the project, this will be restructured into a function
# which receives and IP address & port number and returns the HTTP response to the GET

# This handles HTTP responses from the server, will be correctly implemented later
# (we're actually having some package importing problems, but since this functionality
# isn't really needed, we'll keep things simple for now)
#def handle(pkt):
#    if pkt.haslayer(http.HTTPrequest):
#        print(pkt)
    
# Make a TCP SYN
#ip_address="35.204.58.85"    # Alessandro's server
ip_address="192.168.33.10"    # Matheus' VM (see Vagrantfile)
server_port=80                # http port
ip = IP(dst=ip_address)       # IP Packet 

# HTTP GET Request
ge
t = "GET / HTTP/1.1\r\nHost: " + ip_address + "\r\n\r\n"
port = RandNum(1024,6500)

# The TCP 3-way handshake rules must be followed. As such, we begin by sending a
# TCP packet with the S (or SYN) flag set. The sequence number is irrelevant, as all
# future TCP packets will contain sequence numbers which are increments of the number
# given
SYN = ip/TCP(sport=port, dport=server_port, flags="S", seq=42) 

# Send SYN and wait for SYNACK as response
print(SYN.summary())
SYNACK = sr1(SYN)

# Send ACK and finally HTTP GET, sniff for the result
ACK=ip/TCP(sport=SYNACK.dport, dport=server_port, flags="A", seq=SYNACK.ack, ack=(SYNACK.seq+1))/get
send(ACK)
#sniff(filter="tcp and port 80", store=False, prn=handle) # we'll improve on this later 
\end{lstlisting}

\newpage

\subsection{Résultats}
Le code montré avant est l'état de l'art. Il peut effectivement envoyer les requêtes incomplètes que l'on veut
avec un simple changement de la string ``get''. En l’exécutant avec la commande python2 et en regardant 
le flux de messages sur Wireshark, on voit qu'il a bien réussi d'envoyer messages du type HTTP. Le
\textit{3-way-handshake} du protocole TCP est codé manuellement, faisant attention aux champs de
\textit{ack-number} et \textit{sequence-number}. Le serveur est capable de comprendre les requêtes et
répondre avec une message 200 OK tout en bas.


\begin{figure}[H]
	\begin{center}
          \includegraphics[width=0.8\textwidth]{images/3wayhandshake-get.png} % Include the image placeholder.png
		\caption{Résultats vus sur Wireshark}
                \label{wireshark-dialogue}
	\end{center}
\end{figure}

%--------------------------
\section{Travaux futurs}
Le but des prochains travaux sera d'effectivement mettre une couche logique sur la méthode GET de tel façon
à obtenir le comportement attendu. Dans ce moment, la fonction principal du travail est http.py. La prochaine
étape sera de la transformer en une fonction qui reçoit un adresse IP et un numéro de porte. La logique d'allouer
numéro de portes sera toute faite par loris.py, que l'on développera à la suite.


\begin{thebibliography}{}

\bibitem{rfc}{Internet Engineering Task Force (IETF)\\
\href{https://tools.ietf.org/html/rfc1945}{Request for Comment 1945 - Hypertext Transfer Protocol 1.0}}

\bibitem{http-book}{THOMAS, Stephen \\
HTTP Essentials: Protocols for Secure, Scaleable Web Sites}

\bibitem{apache}{The Apache Group \\
\href{https://httpd.apache.org/docs/2.2/fr/new_features_2_0.html.fr}{Vue d'ensemble des nouvelles fonctionnalités d'Apache 2.0}}

\bibitem{hackers}{Ha.ckers group, archivé \\
\href{https://web.archive.org/web/20150426090206/http://ha.ckers.org/slowloris}{Slowloris HTTP DoS}}

\bibitem{repo}{Dépôt Github \\
\href{https://github.com/llaera/slowloris.pl}{slowloris.pl, a perl implementation}}

\bibitem{repo}{Acunetix website \\
\href{https://www.acunetix.com/blog/articles/slow-http-dos-attacks-mitigate-apache-http-server/}{Acunetix blog - How To Mitigate Slow HTTP DoS Attacks in Apache HTTP Server}}

\end{thebibliography}
\end{document}
